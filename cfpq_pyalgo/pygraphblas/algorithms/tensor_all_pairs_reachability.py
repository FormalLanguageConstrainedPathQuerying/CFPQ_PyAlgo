"""Module contains functions that solves the All-Pairs CFL-reachability problem
using the Kronecker product of Boolean matrices."""
from typing import Tuple, Set, Hashable

import networkx as nx

from pyformlang.cfg import CFG
from pyformlang.rsa import RecursiveAutomaton
from pygraphblas import Matrix, BOOL

from cfpq_pyalgo.pygraphblas import (
    GraphBooleanDecomposition,
    RSMBooleanDecomposition,
    gbd_from_nx_graph,
)

__all__ = [
    "tensor_all_pairs_reachability",
    "build_tensor_index",
    "_transitive_closure",
]


def tensor_all_pairs_reachability(
    graph: nx.MultiDiGraph, grammar: CFG
) -> Set[Tuple[Hashable, Hashable]]:
    """Determines the set of vertex pairs (u, v) in `graph` such that there is a path from u to v
    whose edge labels form a word from the language generated by the context-free grammar `grammar`.

    Parameters
    ----------
    graph: `nx.MultiDiGraph`
        NetworkX MultiDiGraph

    grammar: `CFG`
        Context-free grammar

    Returns
    -------
    pairs: `Set[Tuple[Hashable, Hashable]]`
        Set of CFL-reachable vertices pairs
    """
    # if the `graph` is empty, then the answer is empty
    if graph.number_of_nodes() == 0:
        return set()

    # prepare RSMBooleanDecomposition from GFG
    rsm: RSMBooleanDecomposition = RSMBooleanDecomposition.from_rsa(
        RecursiveAutomaton.from_text(grammar.to_text())
    )

    # prepare GraphBooleanDecomposition from nx.MultiDiGraph
    matrix_graph, nodes_mapping = gbd_from_nx_graph(graph)

    # find transitive closure for each nonterminal of `rsm`
    res, _ = build_tensor_index(matrix_graph, rsm)

    # convert transitive closure for `wcnf.start_variable`
    # to set of pairs of nodes of `graph`
    I, J, _ = res[grammar.start_symbol.to_text()].to_lists()
    return set((nodes_mapping[u], nodes_mapping[v]) for u, v in zip(I, J))


def build_tensor_index(
    graph: GraphBooleanDecomposition, rsm: RSMBooleanDecomposition
) -> Tuple[GraphBooleanDecomposition, Matrix]:
    """Add edges labeled with nonterminal between CFL-reachable vertices and build index for path extraction

    Build the intersection of the `rsm` and the `graph` the Kronecker product of Boolean matrices.
    Based on this matrix, adds the edges marked by non-terminals to the graph.

    Parameters
    ----------
    graph: `GraphBooleanDecomposition`
        Graph decomposed into Boolean matrices

    rsm: `RSMBooleanDecomposition`
        A Recursive State Machine defines context-free language

    Returns
    -------
    (updated_graph, tensor_index): `Tuple[GraphBooleanDecomposition, Matrix]`
        `updated_graph` - Graph with added edges labeled with nonterminal between CFL-reachable vertices
        `tensor_index` - Matrix containing the intersection of a `graph` and `rsm`, allowing you to extract paths
    """
    graph_size = graph.matrices_size
    # Initialize matrices for all labels
    t = GraphBooleanDecomposition(graph.matrices_size)
    for label in rsm.labels:
        if label in graph:
            t[label] = graph[label].dup()
        else:
            t[label] = Matrix.sparse(BOOL, graph_size, graph_size)
    # 0. Boxes with epsilon path
    diagonal = Matrix.identity(BOOL, graph_size, True)
    for nonterminal in rsm.nonterminals:
        if rsm.get_start_state(nonterminal) in rsm.get_final_states(nonterminal):
            t[nonterminal] += diagonal
    del diagonal

    # 1. CFL reachability transitive closure calculation
    kron_size = rsm.matrices_size * graph_size
    changed = True
    while changed:
        changed = False
        # 1.1 Calculation of Kronecker product and its transitive closure
        kron = Matrix.sparse(BOOL, kron_size, kron_size)
        for label in rsm.labels:
            kron += rsm[label].kronecker(t[label])
        _transitive_closure(kron)
        # 1.2 Update graph
        for nonterminal in rsm.nonterminals:
            start_state = rsm.get_start_state(nonterminal)
            block = Matrix.sparse(BOOL, graph_size, graph_size)
            for final_state in rsm.get_final_states(nonterminal):
                start_i = start_state * graph_size
                start_j = final_state * graph_size
                block += kron[
                    start_i : start_i + graph_size - 1,
                    start_j : start_j + graph_size - 1,
                ]
            control_sum = t[nonterminal].nvals
            t[nonterminal] += block
            new_control_sum = t[nonterminal].nvals
            if new_control_sum != control_sum:
                changed = True
    return t, kron


def _transitive_closure(m: Matrix):
    prev = m.nvals
    degree = m
    with BOOL.ANY_PAIR:
        degree = degree @ m
        m += degree
    while prev != m.nvals:
        prev = m.nvals
        with BOOL.ANY_PAIR:
            degree = degree @ m
            m += degree
